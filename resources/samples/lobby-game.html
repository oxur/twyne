
<html>
	<head>
        <meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
		<title>Harlowe To JSON</title>
        <script type='text/javascript'>
            /**
* Twine To JSON
*
* Copyright (c) 2020 Jonathan Schoonhoven
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
* associated documentation files (the 'Software'), to deal in the Software without restriction,
* including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
* and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
* subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies or substantial
* portions of the Software.
*
* THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
* LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

const STORY_TAG_NAME = 'tw-storydata';
const PASSAGE_TAG_NAME = 'tw-passagedata';
const FORMAT_TWINE = 'twine';
const FORMAT_HARLOWE_3 = 'harlowe-3';
const VALID_FORMATS = [FORMAT_TWINE, FORMAT_HARLOWE_3];


/**
 * Convert Twine story to JSON.
 */
function twineToJSON(format) {
    const storyElement = document.getElementsByTagName(STORY_TAG_NAME)[0];
    const storyMeta = getElementAttributes(storyElement);
    const result = {
        uuid: storyMeta.ifid,
        name: storyMeta.name,
        creator: storyMeta.creator,
        creatorVersion: storyMeta['creator-version'],
        schemaName: storyMeta.format,
        schemaVersion: storyMeta['format-version'],
        createdAtMs: Date.now(),
    };
    validate(format);
    const passageElements = Array.from(storyElement.getElementsByTagName(PASSAGE_TAG_NAME));
    result.passages = passageElements.map((passageElement) => {
        return processPassageElement(passageElement, format);
    });
    return result;
}


/**
 * Validate story and inputs. Currently this only validates the format arg. TODO: make this more robust.
 */
function validate(format) {
    const isValidFormat = VALID_FORMATS.some(validFormat => validFormat === format);
    if (!isValidFormat) {
        throw new Error('Format is not valid.');
    }
}


/**
 * Convert the HTML element for a story passage to JSON.
 */
function processPassageElement(passageElement, format) {
    const passageMeta = getElementAttributes(passageElement);
    const result = {
        name: passageMeta.name,
        tags: passageMeta.tags,
        id: passageMeta.pid,
    };
    result.text = passageElement.innerText.trim();
    Object.assign(result, processPassageText(result.text, format));
    result.cleanText = sanitizeText(result.text, result.links, result.hooks, format);
    return result;
}


function processPassageText(passageText, format) {
    const result = { links: [] };
    if (format === FORMAT_HARLOWE_3) {
        result.hooks = [];
    }
    let currentIndex = 0;
    while (currentIndex < passageText.length) {
        const maybeLink = extractLinksAtIndex(passageText, currentIndex);
        if (maybeLink) {
            result.links.push(maybeLink);
            currentIndex += maybeLink.original.length;
        }
        if (format !== FORMAT_HARLOWE_3) {
            currentIndex += 1;
            continue;
        }
        const maybeLeftHook = extractLeftHooksAtIndex(passageText, currentIndex);
        if (maybeLeftHook) {
            result.hooks.push(maybeLeftHook);
            currentIndex += maybeLeftHook.original.length;
        }
        currentIndex += 1;
        const maybeHook = extractHooksAtIndex(passageText, currentIndex);
        if (maybeHook) {
            result.hooks.push(maybeHook);
            currentIndex += maybeHook.original.length;
        }
    }
    return result;
}


function extractLinksAtIndex(passageText, currentIndex) {
    const currentChar = passageText[currentIndex];
    const nextChar = passageText[currentIndex + 1];
    if (currentChar === '[' && nextChar === '[') {
        const link = getSubstringBetweenBrackets(passageText, currentIndex + 1);
        const leftSplit = link.split('<-', 2);
        const rightSplit = link.split('->', 2);
        const original = passageText.substring(currentIndex, currentIndex + link.length + 4);
        if (leftSplit.length === 2) {
            return { linkText: leftSplit[1].trim(), passageName: leftSplit[0].trim(), original: original };
        }
        else if (rightSplit.length === 2) {
            return { linkText: rightSplit[0].trim(), passageName: rightSplit[1].trim(), original: original };
        }
        else {
            return { linkText: link.trim(), passageName: link.trim(), original: original };
        }
    }
}


function extractLeftHooksAtIndex(passageText, currentIndex) {
    const regexAlphaNum = /[a-z0-9]+/i;
    const currentChar = passageText[currentIndex];
    if (currentChar === '|') {
        const maybeHookName = getSubstringBetweenBrackets(passageText, currentIndex, '|', '>');
        if (maybeHookName.match(regexAlphaNum)) {
            const hookStartIndex = currentIndex + maybeHookName.length + 2; // advance to next char after ">"
            const hookStartChar = passageText[hookStartIndex];
            if (hookStartChar === '[') {
                const hookText = getSubstringBetweenBrackets(passageText, hookStartIndex);
                const hookEndIndex = hookStartIndex + hookText.length + 2;
                const original = passageText.substring(currentIndex, hookEndIndex);
                return { hookName: maybeHookName, hookText: hookText, original: original };
            }
        }
    }
}


function extractHooksAtIndex(passageText, currentIndex) {
    const regexAlphaNum = /[a-z0-9]+/i;
    const currentChar = passageText[currentIndex];
    const nextChar = passageText[currentIndex + 1];
    const prevChar = currentIndex && passageText[currentIndex - 1];
    if (currentChar === '[' && nextChar !== '[' && prevChar !== '[') {
        const hookText = getSubstringBetweenBrackets(passageText, currentIndex);
        const hookEndIndex = currentIndex + hookText.length + 2;
        const hookEndChar = passageText[hookEndIndex];
        if (hookEndChar === '<') {
            const maybeHookName = getSubstringBetweenBrackets(passageText, hookEndIndex, '<', '|');
            if (maybeHookName.match(regexAlphaNum)) {
                const original = passageText.substring(currentIndex, hookEndIndex + maybeHookName.length + 2);
                return { hookName: maybeHookName, hookText: hookText, original: original };
            }
        }
        const original = passageText.substring(currentIndex, hookText.length + 2);
        return { hookName: undefined, hookText: hookText, original: original };
    }
}


function sanitizeText(passageText, links, hooks, format) {
    links.forEach((link) => {
        passageText = passageText.replace(link.original, '');
    });
    if (format === FORMAT_HARLOWE_3) {
        hooks.forEach((hook) => {
            passageText = passageText.replace(hook.original, '');
        });
    }
    return passageText.trim();
}


/**
 * Convert an HTML element to an object of attribute values.
 */
function getElementAttributes(element) {
    const result = {};
    const attributes = Array.from(element.attributes);
    attributes.forEach((attribute) => {
        result[attribute.name] = attribute.value;
    });
    return result;
}


/**
 * True if string starts with the given substring.
 */
function stringStartsWith(string, startswith) {
    return string.trim().substring(0, startswith.length) === startswith;
}


function getSubstringBetweenBrackets(string, startIndex, openBracket, closeBracket) {
    openBracket = openBracket || '[';
    closeBracket = closeBracket || ']';
    const bracketStack = [];
    let currentIndex = startIndex || 0;
    let substring = '';
    if (string[currentIndex] !== openBracket) {
        throw new Error('startIndex of getSubstringBetweenBrackets must correspond to an open bracket');
    }
    while (currentIndex < string.length) {
        const currentChar = string[currentIndex];
        // pull top bracket from stack if we hit a close bracket
        if (currentChar === closeBracket) {
            bracketStack.pop();
        }
        // build substring so long as stack is populated
        if (bracketStack.length) {
            substring += currentChar;
        }
        // add open brackets to the top of the stack
        if (currentChar === openBracket) {
            bracketStack.push(currentChar);
        }
        // return if stack is empty and substring is set
        if (!bracketStack.length) {
            return substring;
        }
        currentIndex += 1;
    }
    return substring;
}

        </script>
	</head>
	<body>
        <pre id='content'></pre>
        <div id='storyData' style='display: none;'><tw-storydata name="Lobby" startnode="1" creator="Twine" creator-version="2.5.1" format="Harlowe 3 to JSON" format-version="0.0.6" ifid="D4C8A67F-7ABD-4E85-8200-6F38CABBE45C" options="" tags="" zoom="1" hidden><style role="stylesheet" id="twine-user-stylesheet" type="text/twine-css"></style><script role="script" id="twine-user-script" type="text/twine-javascript"></script><tw-tag name="starting-place" color="green"></tw-tag><tw-tag name="home" color="yellow"></tw-tag><tw-tag name="starting-zone" color="green"></tw-tag><tw-tag name="initial-area" color="green"></tw-tag><tw-passagedata pid="1" name="Lobby" tags="home starting-place starting-zone initial-area" position="800,400" size="100,100">You are in a lobby -- THE lobby -- and it&#39;s exaclty the sort of lobby you&#39;ve fantasised about your whole life. You couldn&#39;t have designed a better one. It is, simply put, the very embodiment of aesthetic perfection itself.

While casting your eyes about its magnificence, upward glances reveal several signs above wildly varried thresholds, each enticing you to enter its mysterious subdomain. 

The most exiting looking signs are [[Create Character]], [[Join Game]] and the mind-blowingly beautiful [[Manage Account]]. A sign labelled with the promising &quot;Add Game&quot; declares its undying belief in a bright and proud future. It has staked out its territory over a pile of rubble behind which you believe you catch a fleeting glimpse of dark, cavernous nothingness.

There are two pillars off to the side, one with a sign saying &quot;List Games&quot; and another with &quot;List Characters&quot;. You feel that if you look at these you will gain much worldly knowledge.

Two very threatening-looking rooms in the back have signs that say ... something. It&#39;s hard to tell, being so poorly lit that far from the other, infinitely more used rooms. You think you can make out [[Delete Character]] and [[Delete Account]]. You shudder with fear, knowing that, if you parsed the signs corectly, those rooms are not for you. 

Simply best to forget they even exist.</tw-passagedata><tw-passagedata pid="2" name="Create Character" tags="" position="800,575" size="100,100">If it was possible for a room to have more promise that the lobby behind you (a lobby whose beauty caused tears to freely flow down your cheeks), it is this one. It is a maze of wonderful twists and turns, like a lush art museam carved into the depths of the earth itself. 

There are even museum-quality frames on the walls, viewable in every nook you can see from where you stand. The frames tower over you, and if they held art, each would be a vast universe unto itself. There are benches for admiring this art-potential under each.

You can see that the nooks seem to have passages that leads away, to what you can only assume are other, even more private, nooks. There are so many little areas for future paintings that you quickly note their strategic value for future reference: this would be a great place to eat a boxed lunch on a work day, have a romantic rendezvous, or ... both.

Descrete labelling and exquisite design lead you to the inexorably logical and unerringly correct conclusion: each bench will let you create a character by visualising one in the luxurious frame above it. 

Afterwards, you know that the character will pull you down a passage into the world to which it belongs. You can barely contain your excitement.

At which bench do you wish to sit? (Or perhaps the siren song of the [[Lobby]]  calls to you?)</tw-passagedata><tw-passagedata pid="3" name="Join Game" tags="" position="925,525" size="100,100">As you enter this room, the relaxing and gently circulating air of the lobby transforms into near gales of wind that rush into portals which open onto other worlds, ripe for exploration. Your excitement is so great and your ability to contain it so feeble that you nearly exclaim with relief when you remember a recent relinquishing of liquid burden in a majestically appointed water closet off the lobby, mere minutes ago.

Crescendos of horns and strings drive your anticiaption into a near frenzy (and a possible retreat for another visit to the WC) as you view the options before you: which portal shall you choose?

Or maybe the [[Lobby]] instead?</tw-passagedata><tw-passagedata pid="4" name="Delete Character" tags="" position="475,675" size="100,100">Do people actually come IN here?

Did you, really?

Or is this, in fact, a nightmare from which you desperately desire to awaken?

It almost certainly is! Shall we repair to the [[Lobby]]  instead? I hear the hors d&#39;oeuvres there are delectable ... and free!

In the event that you really do want to be in this dark hole, it seems you can do the following:</tw-passagedata><tw-passagedata pid="5" name="Manage Account" tags="" position="950,375" size="100,100">So much comfy furniture! Such astounding lighting! What artistry! What incredible ambience! Banish all thought of being elsewhere! THIS is where you BELONG!

Let the managing COMMENCE! (Or you could always return to the [[Lobby]] ...)

Which of the following would you like to do?</tw-passagedata><tw-passagedata pid="6" name="Delete Account" tags="" position="300,575" size="100,100">Oh, no ... no, no, no, no, no ... not like this, not like this ...

And you thought the &quot;Delete Character&quot; room was bad? This howling emptiness is an abattoir of the imagination, a gibbering denial of truth, beauty, and play.

I beg of your kindness: let us rescue ourselves from this insanity&#39;s brink! 

With all haste, to the [[Lobby]]!

Or ... you could delete your account, finishing this teeter into the abyss ...</tw-passagedata></tw-storydata></div>
        <script type='text/javascript'>document.getElementById('content').innerHTML = JSON.stringify(twineToJSON("harlowe-3"), null, 2);</script>
	</body>
</html>
